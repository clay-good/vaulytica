# Vulnerability Management AI Agent

**Version**: 1.0.0 (Planned)
**Status**: Design Phase
**Target Release**: Q1 2026
**Last Updated**: 2025-10-21

---

## Overview

The Vulnerability Management Agent bridges security and engineering teams by ingesting vulnerability findings from Wiz and SocketDev, enriching them with business context, and automating remediation workflows through GitLab/GitHub and Jira.

### Design Philosophy

**Complement, Don't Compete**: This agent integrates with existing tools (Wiz, SocketDev, GitLab, Jira) rather than replacing them. It adds AI-powered intelligence and automation on top of your existing security stack.

### Key Capabilities

- **Wiz Integration**: Ingest vulnerability findings, SBOM data, cloud asset inventory
- **SocketDev Integration**: Cross-validate dependency vulnerabilities, supply chain risk analysis
- **GitLab/GitHub Integration**: Analyze repositories, create merge requests with fixes, run CI/CD validation
- **Jira Enrichment**: Transform Wiz-created Jira tickets with business context and remediation guidance
- **SBOM Analysis**: Transitive dependency analysis, vulnerability path tracing
- **Automated Remediation**: Container image updates, dependency patches, IaC fixes
- **Ownership Detection**: Automatic assignment to correct teams

---

## Architecture

### Vulnerability Management Workflow

```
Wiz Detects Vulnerability
    ↓
Wiz Creates Jira Ticket
    ↓
AI Agent Ingests Jira Ticket
    ↓
1. Enrichment Phase
   - Query Wiz API for full vulnerability details
   - Query SocketDev for dependency analysis
   - Analyze SBOM (transitive dependencies)
   - Trace vulnerability path
   - Determine business criticality
    ↓
2. Context Analysis Phase
   - Find GitLab/GitHub repository
   - Identify code owners (CODEOWNERS, git history)
   - Check deployment frequency
   - Assess customer impact
   - Calculate risk score
    ↓
3. Remediation Planning Phase
   - Generate fix recommendations
   - Create GitLab/GitHub merge request
   - Run CI/CD tests (dry-run)
   - Estimate effort and risk
    ↓
4. Jira Ticket Update Phase
   - Add business context
   - Add remediation guidance
   - Attach MR/PR link
   - Assign to correct team
   - Set priority based on risk
    ↓
5. Validation Phase
   - Monitor MR/PR status
   - Validate fix deployment
   - Re-scan with Wiz/SocketDev
   - Auto-close Jira ticket if fixed
   - Track MTTR metrics
    ↓
Vulnerability Remediated
```

---

## Integration Strategy

### Wiz Integration

**What Wiz Provides**:
- Cloud asset inventory (AWS, GCP, Azure)
- Container image vulnerability scanning
- Kubernetes security posture
- IaC misconfigurations
- SBOM generation
- Jira ticket creation

**What AI Agent Adds**:
- Business context enrichment
- Transitive dependency analysis
- Automated remediation (MR/PR creation)
- Ownership detection
- Remediation validation
- MTTR tracking

**API Integration**:
```python
from vaulytica.integrations.wiz import WizIntegration

wiz = WizIntegration(
    client_id=config.wiz_client_id,
    client_secret=config.wiz_client_secret,
    api_url="https://example.com"
)

# Get vulnerability details
vulnerability = await wiz.get_vulnerability(vuln_id="vuln-123")

# Get SBOM for affected asset
sbom = await wiz.get_sbom(asset_id=vulnerability.asset_id)

# Get cloud asset details
asset = await wiz.get_asset(asset_id=vulnerability.asset_id)
```

### SocketDev Integration

**What SocketDev Provides**:
- Dependency vulnerability scanning
- Supply chain risk analysis
- Malicious package detection
- License compliance

**What AI Agent Adds**:
- Cross-validation with Wiz findings
- Prioritization based on exploitability
- Automated dependency updates
- Transitive dependency path analysis

**API Integration**:
```python
from vaulytica.integrations.socketdev import SocketDevIntegration

socketdev = SocketDevIntegration(api_key=config.socketdev_api_key)

# Analyze package
analysis = await socketdev.analyze_package(
    ecosystem="npm",
    package="lodash",
    version="4.17.20"
)

# Get vulnerability details
vulns = await socketdev.get_vulnerabilities(
    ecosystem="npm",
    package="lodash"
)
```

### GitLab/GitHub Integration

**Capabilities**:
- Repository analysis (dependencies, owners, activity)
- Merge request / Pull request creation
- CI/CD pipeline triggering
- Code review automation
- Merge status tracking

**GitLab Example**:
```python
from vaulytica.integrations.gitlab import GitLabIntegration

gitlab = GitLabIntegration(
    url="https://gitlab.example.com",
    token=config.gitlab_token
)

# Find repository for vulnerable service
repo = await gitlab.find_repository_by_service(service_name="api-gateway")

# Analyze dependencies
dependencies = await gitlab.get_dependencies(
    project_id=repo.id,
    file_path="package.json"
)

# Create merge request with fix
mr = await gitlab.create_vulnerability_fix_mr(
    project_id=repo.id,
    vulnerability=vulnerability,
    fix_description="Update lodash to 4.17.21 to fix CVE-2021-23337",
    source_branch="security/fix-cve-2021-23337",
    target_branch="main",
    changes=[
        {
            "file_path": "package.json",
            "content": updated_package_json
        }
    ]
)

# Trigger CI/CD pipeline
pipeline = await gitlab.trigger_pipeline(
    project_id=repo.id,
    ref=mr.source_branch
)
```

---

## SBOM Analysis

### Transitive Dependency Analysis

**Problem**: Vulnerability in deeply nested dependency
```
your-app (package.json)
   express@4.17.1
       body-parser@1.19.0
           qs@6.7.0  ← VULNERABLE (CVE-2022-24999)
```

**AI Agent Solution**:
```python
# Trace vulnerability path
path = await agent.trace_vulnerability_path(
    sbom=sbom,
    vulnerable_package="qs",
    vulnerable_version="6.7.0"
)

# Output:
{
  "vulnerability": "CVE-2022-24999",
  "vulnerable_package": "qs@6.7.0",
  "dependency_path": [
    "your-app",
    "express@4.17.1",
    "body-parser@1.19.0",
    "qs@6.7.0"
  ],
  "fix_recommendation": {
    "action": "Update express to 4.18.0 which uses body-parser 1.20.0 with patched qs",
    "direct_dependency": "express",
    "current_version": "4.17.1",
    "fixed_version": "4.18.0",
    "breaking_changes": false
  }
}
```

### Cross-Validation (Wiz + SocketDev)

```python
# Get findings from both sources
wiz_findings = await wiz.get_vulnerabilities(asset_id="asset-123")
socketdev_findings = await socketdev.get_vulnerabilities(
    ecosystem="npm",
    package="lodash"
)

# Cross-validate
validated = await agent.cross_validate_findings(
    wiz_findings=wiz_findings,
    socketdev_findings=socketdev_findings
)

# Output:
{
  "confirmed_vulnerabilities": [
    {
      "cve": "CVE-2021-23337",
      "package": "lodash@4.17.20",
      "confirmed_by": ["wiz", "socketdev"],
      "confidence": 1.0,
      "priority": "HIGH"
    }
  ],
  "wiz_only": [...],  # Vulnerabilities only found by Wiz
  "socketdev_only": [...]  # Vulnerabilities only found by SocketDev
}
```

---

## Jira Ticket Enrichment

### Before AI Agent

**Wiz-Created Jira Ticket**:
```
Title: CVE-2021-23337 in lodash

Description:
Vulnerability: CVE-2021-23337
Package: lodash@4.17.20
Severity: HIGH
CVSS: 7.5

Asset: container-image-abc123
```

### After AI Agent Enrichment

**AI-Enriched Jira Ticket**:
```
Title: [HIGH] CVE-2021-23337 in lodash - api-gateway-prod (Customer-Facing)

Description:
## Vulnerability Summary
**CVE**: CVE-2021-23337
**Package**: lodash@4.17.20
**Severity**: HIGH (CVSS 7.5)
**Exploitability**: Public exploit available

## Business Context
**Affected Service**: api-gateway-prod
**Service Owner**: @platform-team
**Business Criticality**: CRITICAL (customer-facing, 10M requests/day)
**Deployment Frequency**: 5x/week (high velocity)
**Last Deployed**: 2025-10-15 (6 days ago)

## Technical Details
**Container Image**: api-gateway:v1.2.3
**Repository**: https://gitlab.example.com
**Dependency Path**: api-gateway → express@4.17.1 → body-parser@1.19.0 → qs@6.7.0 → lodash@4.17.20

## Remediation Guidance
**Recommended Fix**: Update lodash to 4.17.21
**Estimated Effort**: 1 hour (automated MR created, tests passing)
**Breaking Changes**: None
**Rollback Plan**: Instant rollback via Kubernetes deployment

## Automated Actions Taken
-  Created GitLab MR: !1234 (https://gitlab.example.com)
-  CI/CD tests passed (15/15 tests green)
-  Security scan passed (no new vulnerabilities introduced)
-  Ready for review and merge

## Cross-Validation
-  Confirmed by Wiz
-  Confirmed by SocketDev
-  Confidence: 100%

## Risk Assessment
**If Not Fixed**:
- Potential for command injection attacks
- Customer data exposure risk
- Regulatory compliance impact (GDPR, SOC2)

**Priority**: HIGH (fix within 7 days per SLA)

---
Assigned to: @platform-team
Labels: security, vulnerability, high-priority, customer-facing
```

---

## Automated Remediation

### Container Image Patching (Highest ROI)

```python
# Detect vulnerable container image
vulnerability = {
  "cve": "CVE-2021-23337",
  "package": "lodash@4.17.20",
  "container_image": "api-gateway:v1.2.3"
}

# AI Agent creates fix
fix = await agent.create_container_fix(
    vulnerability=vulnerability,
    repository="company/api-gateway"
)

# Actions taken:
# 1. Clone repository
# 2. Update package.json: lodash 4.17.20 → 4.17.21
# 3. Run npm install
# 4. Update Dockerfile if needed
# 5. Create GitLab MR
# 6. Trigger CI/CD pipeline
# 7. Wait for tests to pass
# 8. Notify team for review

# Output:
{
  "merge_request_url": "https://gitlab.example.com",
  "ci_status": "passed",
  "tests_passed": 15,
  "tests_failed": 0,
  "ready_for_merge": true,
  "estimated_deployment_time": "10 minutes"
}
```

### Dependency Update Automation

```python
# Update dependency in package.json
await agent.update_dependency(
    repository="company/api-gateway",
    file_path="package.json",
    package="lodash",
    from_version="4.17.20",
    to_version="4.17.21"
)

# Update dependency in requirements.txt
await agent.update_dependency(
    repository="company/python-service",
    file_path="requirements.txt",
    package="requests",
    from_version="2.25.0",
    to_version="2.31.0"
)

# Update dependency in go.mod
await agent.update_dependency(
    repository="company/go-service",
    file_path="go.mod",
    package="github.com/gin-gonic/gin",
    from_version="v1.7.0",
    to_version="v1.9.0"
)
```

---

## Ownership Detection

### Multi-Source Ownership Resolution

```python
# Detect service owner from multiple sources
owner = await agent.detect_owner(
    service_name="api-gateway-prod",
    repository="company/api-gateway"
)

# Sources checked (in priority order):
# 1. GitLab CODEOWNERS file
# 2. Wiz asset tags (Owner, Team, Contact)
# 3. Datadog service catalog
# 4. PagerDuty on-call schedule
# 5. Git commit history (most active contributors)

# Output:
{
  "team": "platform-team",
  "primary_contact": "user@example.com",
  "secondary_contact": "user@example.com",
  "pagerduty_escalation": "platform-team-escalation",
  "slack_channel": "#platform-team",
  "confidence": 0.95,
  "source": "CODEOWNERS"
}
```

---

## Validation & Metrics

### Remediation Validation

```python
# After MR is merged and deployed
validation = await agent.validate_remediation(
    vulnerability_id="vuln-123",
    jira_ticket="SEC-456"
)

# Actions:
# 1. Wait for deployment (monitor GitLab/Kubernetes)
# 2. Re-scan with Wiz
# 3. Re-scan with SocketDev
# 4. Confirm vulnerability is gone
# 5. Auto-close Jira ticket with evidence

# Output:
{
  "vulnerability_fixed": true,
  "wiz_scan_result": "no_vulnerabilities",
  "socketdev_scan_result": "no_vulnerabilities",
  "deployment_verified": true,
  "jira_ticket_closed": true,
  "mttr_seconds": 3600  # 1 hour from detection to fix
}
```

### MTTR Tracking

```python
# Track Mean Time To Remediate by team
metrics = await agent.get_mttr_metrics(
    team="platform-team",
    timeframe="last_30_days"
)

# Output:
{
  "team": "platform-team",
  "vulnerabilities_fixed": 45,
  "average_mttr_hours": 12.5,
  "median_mttr_hours": 8.0,
  "fastest_fix_hours": 1.5,
  "slowest_fix_hours": 72.0,
  "sla_compliance": 0.89  # 89% fixed within SLA
}
```

---

## Configuration

```python
from vaulytica.agents.vulnerability_management import VulnerabilityManagementAgent

agent = VulnerabilityManagementAgent(
    config=config,
    wiz_client_id="your-wiz-client-id",
    wiz_client_secret="your-wiz-secret",
    socketdev_api_key="your-socketdev-key",
    gitlab_url="https://gitlab.example.com",
    gitlab_token="your-gitlab-token",
    jira_url="https://your-company.atlassian.net",
    jira_username="user@example.com",
    jira_api_token="your-jira-token",
    auto_create_mrs=True,  # Automatically create merge requests
    auto_merge=False,  # Require human approval before merging
    dry_run=False  # Set to True for testing without making changes
)
```

---

## Best Practices

1. **Start with Container Images**: Highest ROI, lowest risk
2. **Enable Dry-Run Mode**: Test automation before enabling auto-MR creation
3. **Require Human Approval**: Set auto_merge=False for safety
4. **Cross-Validate Findings**: Use both Wiz and SocketDev for confidence
5. **Track MTTR by Team**: Identify bottlenecks and improve processes
6. **Monitor CI/CD Results**: Ensure automated fixes don't break tests

---

## Roadmap

**Phase 1** (Q1 2026): Wiz + Jira integration, SBOM analysis
**Phase 2** (Q2 2026): GitLab/GitHub MR automation, CI/CD validation
**Phase 3** (Q3 2026): SocketDev integration, cross-validation
**Phase 4** (Q4 2026): Advanced remediation (IaC, Kubernetes manifests)

---

## Example Workflow

```python
# Complete vulnerability management workflow

# 1. Wiz detects vulnerability and creates Jira ticket
# 2. AI Agent monitors Jira for new security tickets

from vaulytica.agents.vulnerability_management import VulnerabilityManagementAgent

agent = VulnerabilityManagementAgent(config)

# 3. Agent ingests Jira ticket
jira_ticket = await agent.monitor_jira_tickets(
    project_key="SEC",
    labels=["wiz", "vulnerability"]
)

# 4. Enrich with Wiz + SocketDev data
enriched = await agent.enrich_vulnerability(
    jira_ticket_id="SEC-456",
    wiz_vuln_id="vuln-123"
)

# 5. Analyze SBOM and trace dependency path
sbom_analysis = await agent.analyze_sbom(
    asset_id=enriched.asset_id
)

# 6. Create GitLab MR with fix
mr = await agent.create_remediation_mr(
    vulnerability=enriched,
    sbom_analysis=sbom_analysis
)

# 7. Update Jira ticket with enrichment
await agent.update_jira_ticket(
    ticket_id="SEC-456",
    enrichment=enriched,
    merge_request=mr
)

# 8. Monitor MR status and validate fix
await agent.monitor_remediation(
    ticket_id="SEC-456",
    merge_request_id=mr.id
)
```

---

## Support

For questions or feedback:
- GitHub Issues: https://example.com
- Documentation: https://docs.vaulytica.com

