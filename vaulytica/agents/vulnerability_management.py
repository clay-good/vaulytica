"""
Vulnerability Management Agent - Core Implementation

Bridges security and engineering teams by ingesting vulnerability findings,
enriching them with business context, and automating remediation workflows.

Version: 1.0.0
Author: Vaulytica Team
"""

import time
import asyncio
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum

from .framework import (
    BaseAgent,
    AgentCapability,
    AgentStatus,
    AgentContext,
    AgentInput,
    AgentOutput
)
from vaulytica.config import VaulyticaConfig, get_config
from vaulytica.logger import get_logger
from vaulytica.jira_integration import JiraIssueManager, JiraAPIClient

logger = get_logger(__name__)


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFORMATIONAL = "informational"


class RemediationStatus(Enum):
    """Remediation workflow status"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    MR_CREATED = "mr_created"
    CI_RUNNING = "ci_running"
    CI_PASSED = "ci_passed"
    CI_FAILED = "ci_failed"
    MERGED = "merged"
    DEPLOYED = "deployed"
    VALIDATED = "validated"
    CLOSED = "closed"


@dataclass
class VulnerabilityFinding:
    """Vulnerability finding from Wiz or other scanner"""
    vulnerability_id: str
    cve_id: Optional[str] = None
    package_name: str = ""
    package_version: str = ""
    severity: VulnerabilitySeverity = VulnerabilitySeverity.MEDIUM
    cvss_score: float = 0.0
    description: str = ""
    affected_asset_id: Optional[str] = None
    affected_asset_name: Optional[str] = None
    source: str = "unknown"  # wiz, socketdev, etc.
    discovered_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class DependencyPath:
    """Transitive dependency path to vulnerable package"""
    root_package: str
    vulnerable_package: str
    path: List[str] = field(default_factory=list)
    depth: int = 0
    direct_dependency: Optional[str] = None


@dataclass
class RemediationPlan:
    """Automated remediation plan"""
    vulnerability_id: str
    action: str  # "update_dependency", "patch_code", "update_container", etc.
    description: str
    direct_dependency: Optional[str] = None
    current_version: Optional[str] = None
    fixed_version: Optional[str] = None
    breaking_changes: bool = False
    estimated_effort_hours: float = 0.0
    risk_level: str = "low"  # low, medium, high
    automated: bool = False
    mr_url: Optional[str] = None
    ci_status: Optional[str] = None


class VulnerabilityManagementAgent(BaseAgent):
    """
    Vulnerability Management Agent for automated vulnerability remediation.

    This agent bridges security and engineering teams by:
    - Ingesting vulnerability findings from Wiz, SocketDev, etc.
    - Enriching findings with business context
    - Analyzing SBOM and transitive dependencies
    - Creating automated remediation MRs/PRs
    - Enriching Jira tickets with context and guidance
    - Tracking remediation progress and MTTR

    Capabilities:
    - Vulnerability ingestion and enrichment
    - SBOM analysis and dependency path tracing
    - Automated remediation planning
    - GitLab/GitHub integration for MR/PR creation
    - Jira ticket enrichment
    - Remediation validation and tracking
    """

    def __init__(self, config: Optional[VaulyticaConfig] = None):
        """Initialize Vulnerability Management Agent"""
        if config is None:
            config = get_config()

        super().__init__(
            agent_id="vulnerability-management-agent",
            agent_name="Vulnerability Management Agent",
            agent_version="1.0.0",
            capabilities=[
                AgentCapability.VULNERABILITY_MANAGEMENT,
                AgentCapability.SBOM_ANALYSIS,
                AgentCapability.AUTOMATED_REMEDIATION
            ],
            description="Automated vulnerability management with business context enrichment"
        )

        self.config = config

        # Initialize Jira integration
        self.jira_manager: Optional[JiraIssueManager] = None
        if config.jira_url and config.jira_username and config.jira_api_token and config.jira_project_key:
            try:
                api_client = JiraAPIClient(
                    base_url=config.jira_url,
                    username=config.jira_username,
                    api_token=config.jira_api_token
                )
                self.jira_manager = JiraIssueManager(
                    api_client=api_client,
                    project_key=config.jira_project_key,
                    default_issue_type="Vulnerability"
                )
                logger.info("Jira integration initialized for vulnerability management")
            except Exception as e:
                logger.warning(f"Failed to initialize Jira integration: {e}")
                self.jira_manager = None

        # Statistics
        self.statistics = {
            "vulnerabilities_processed": 0,
            "vulnerabilities_enriched": 0,
            "remediation_plans_created": 0,
            "mrs_created": 0,
            "vulnerabilities_fixed": 0,
            "jira_tickets_enriched": 0
        }

        logger.info(f"Initialized {self.agent_name} v{self.agent_version}")

    async def execute(self, input_data: AgentInput) -> AgentOutput:
        """
        Execute vulnerability management task.

        Supported tasks:
        - "enrich_vulnerability": Enrich vulnerability with business context
        - "analyze_sbom": Analyze SBOM and trace dependency paths
        - "create_remediation_plan": Generate automated remediation plan
        - "enrich_jira_ticket": Enrich Jira ticket with context and guidance
        - "comprehensive_vulnerability_management": Full workflow

        Args:
            input_data: Input containing context, task, and parameters

        Returns:
            AgentOutput with vulnerability management results
        """
        start_time = time.time()
        self._update_status(AgentStatus.RUNNING)

        try:
            # Validate input
            await self.validate_input(input_data)

            # Route to appropriate handler based on task
            task = input_data.task.lower().replace("_", " ")

            if "enrich vulnerability" in task or "enrich finding" in task:
                output = await self._enrich_vulnerability(input_data, start_time)
            elif "analyze sbom" in task or "dependency" in task:
                output = await self._analyze_sbom(input_data, start_time)
            elif "remediation plan" in task or "create plan" in task:
                output = await self._create_remediation_plan(input_data, start_time)
            elif "enrich jira" in task or "update jira" in task:
                output = await self._enrich_jira_ticket(input_data, start_time)
            elif "comprehensive" in task or "full workflow" in task:
                output = await self._comprehensive_vulnerability_management(input_data, start_time)
            else:
                # Default: comprehensive vulnerability management
                output = await self._comprehensive_vulnerability_management(input_data, start_time)

            self._update_status(AgentStatus.COMPLETED)
            logger.info(f"Vulnerability management task completed in {output.execution_time:.2f}s")

            return output

        except Exception as e:
            self._update_status(AgentStatus.FAILED)
            logger.error(f"Vulnerability management failed: {e}")

            return AgentOutput(
                agent_id=self.agent_id,
                agent_name=self.agent_name,
                status=AgentStatus.FAILED,
                results={},
                confidence=0.0,
                reasoning=[f"Vulnerability management failed: {str(e)}"],
                data_sources_used=[],
                recommendations=[],
                next_actions=["Review error logs", "Retry with valid input"],
                audit_trail=[],
                execution_time=time.time() - start_time,
                error=str(e)
            )

    async def validate_input(self, input_data: AgentInput) -> bool:
        """Validate input data"""
        if not input_data.context:
            raise ValueError("AgentContext is required")

        return True

    async def _enrich_vulnerability(
        self,
        input_data: AgentInput,
        start_time: float
    ) -> AgentOutput:
        """
        Enrich vulnerability finding with business context.

        This includes:
        - Asset identification and ownership
        - Business criticality assessment
        - Deployment frequency analysis
        - Customer impact estimation
        - Risk score calculation
        """
        context = input_data.context
        vulnerability_data = context.data_sources.get("vulnerability", {})

        logger.info(f"Enriching vulnerability: {vulnerability_data.get('vulnerability_id', 'unknown')}")

        # Extract vulnerability details
        finding = self._parse_vulnerability_finding(vulnerability_data)

        # Enrich with business context
        enrichment = {
            "vulnerability_id": finding.vulnerability_id,
            "cve_id": finding.cve_id,
            "package": f"{finding.package_name}@{finding.package_version}",
            "severity": finding.severity.value,
            "cvss_score": finding.cvss_score,
            "business_context": self._assess_business_context(finding, context),
            "risk_score": self._calculate_risk_score(finding, context),
            "ownership": self._determine_ownership(finding, context),
            "priority": self._determine_priority(finding, context)
        }

        self.statistics["vulnerabilities_enriched"] += 1

        return AgentOutput(
            agent_id=self.agent_id,
            agent_name=self.agent_name,
            status=AgentStatus.COMPLETED,
            results={"enrichment": enrichment},
            confidence=0.85,
            reasoning=["Enriched vulnerability with business context"],
            data_sources_used=list(context.data_sources.keys()),
            recommendations=[],
            next_actions=["Analyze SBOM", "Create remediation plan"],
            audit_trail=[],
            execution_time=time.time() - start_time
        )

    async def _analyze_sbom(
        self,
        input_data: AgentInput,
        start_time: float
    ) -> AgentOutput:
        """
        Analyze SBOM and trace dependency paths to vulnerable packages.
        """
        context = input_data.context
        sbom_data = context.data_sources.get("sbom", {})
        vulnerability_data = context.data_sources.get("vulnerability", {})

        logger.info("Analyzing SBOM for vulnerability paths")

        finding = self._parse_vulnerability_finding(vulnerability_data)

        # Trace dependency path
        dependency_path = self._trace_dependency_path(
            sbom_data,
            finding.package_name,
            finding.package_version
        )

        # Analyze transitive dependencies
        analysis = {
            "vulnerable_package": f"{finding.package_name}@{finding.package_version}",
            "dependency_path": dependency_path.path if dependency_path else [],
            "depth": dependency_path.depth if dependency_path else 0,
            "direct_dependency": dependency_path.direct_dependency if dependency_path else None,
            "is_direct": dependency_path.depth == 1 if dependency_path else False,
            "total_dependencies": len(sbom_data.get("dependencies", [])),
            "vulnerable_dependencies": self._count_vulnerable_dependencies(sbom_data)
        }

        return AgentOutput(
            agent_id=self.agent_id,
            agent_name=self.agent_name,
            status=AgentStatus.COMPLETED,
            results={"sbom_analysis": analysis},
            confidence=0.90,
            reasoning=["Analyzed SBOM and traced dependency paths"],
            data_sources_used=["sbom", "vulnerability"],
            recommendations=[],
            next_actions=["Create remediation plan"],
            audit_trail=[],
            execution_time=time.time() - start_time
        )

    async def _create_remediation_plan(
        self,
        input_data: AgentInput,
        start_time: float
    ) -> AgentOutput:
        """
        Create automated remediation plan with fix recommendations.
        """
        context = input_data.context
        vulnerability_data = context.data_sources.get("vulnerability", {})
        sbom_data = context.data_sources.get("sbom", {})

        logger.info("Creating remediation plan")

        finding = self._parse_vulnerability_finding(vulnerability_data)
        dependency_path = self._trace_dependency_path(
            sbom_data,
            finding.package_name,
            finding.package_version
        )

        # Generate remediation plan
        plan = self._generate_remediation_plan(finding, dependency_path, context)

        self.statistics["remediation_plans_created"] += 1

        return AgentOutput(
            agent_id=self.agent_id,
            agent_name=self.agent_name,
            status=AgentStatus.COMPLETED,
            results={"remediation_plan": plan},
            confidence=0.80,
            reasoning=["Generated automated remediation plan"],
            data_sources_used=["vulnerability", "sbom"],
            recommendations=[plan.get("description", "")],
            next_actions=["Create MR/PR", "Enrich Jira ticket"],
            audit_trail=[],
            execution_time=time.time() - start_time
        )

    async def _enrich_jira_ticket(
        self,
        input_data: AgentInput,
        start_time: float
    ) -> AgentOutput:
        """
        Enrich Jira ticket with business context and remediation guidance.
        """
        context = input_data.context
        jira_key = context.data_sources.get("jira_key")

        if not jira_key or not self.jira_manager:
            logger.warning("Jira key or Jira manager not available")
            return AgentOutput(
                agent_id=self.agent_id,
                agent_name=self.agent_name,
                status=AgentStatus.COMPLETED,
                results={"enriched": False, "reason": "Jira not configured"},
                confidence=0.0,
                reasoning=["Jira integration not available"],
                data_sources_used=[],
                recommendations=[],
                next_actions=[],
                audit_trail=[],
                execution_time=time.time() - start_time
            )

        logger.info(f"Enriching Jira ticket: {jira_key}")

        # Get enrichment data
        vulnerability_data = context.data_sources.get("vulnerability", {})
        enrichment = context.data_sources.get("enrichment", {})
        remediation_plan = context.data_sources.get("remediation_plan", {})

        # Build enrichment comment
        comment = self._build_jira_enrichment_comment(
            vulnerability_data,
            enrichment,
            remediation_plan
        )

        # Add comment to Jira
        success = await self.jira_manager.api_client.add_comment(jira_key, comment)

        if success:
            self.statistics["jira_tickets_enriched"] += 1

        return AgentOutput(
            agent_id=self.agent_id,
            agent_name=self.agent_name,
            status=AgentStatus.COMPLETED,
            results={"enriched": success, "jira_key": jira_key},
            confidence=0.95,
            reasoning=["Enriched Jira ticket with context and guidance"],
            data_sources_used=list(context.data_sources.keys()),
            recommendations=[],
            next_actions=["Monitor remediation progress"],
            audit_trail=[],
            execution_time=time.time() - start_time
        )

    async def _comprehensive_vulnerability_management(
        self,
        input_data: AgentInput,
        start_time: float
    ) -> AgentOutput:
        """
        Perform comprehensive vulnerability management workflow.

        Executes: enrichment â†’ SBOM analysis â†’ remediation planning â†’ Jira enrichment
        """
        context = input_data.context

        logger.info("Performing comprehensive vulnerability management")

        # Execute all tasks
        enrich_output = await self._enrich_vulnerability(input_data, time.time())
        sbom_output = await self._analyze_sbom(input_data, time.time())
        remediation_output = await self._create_remediation_plan(input_data, time.time())

        # Enrich Jira if configured
        jira_output = None
        if context.data_sources.get("jira_key"):
            jira_output = await self._enrich_jira_ticket(input_data, time.time())

        # Aggregate results
        comprehensive_results = {
            "enrichment": enrich_output.results.get("enrichment", {}),
            "sbom_analysis": sbom_output.results.get("sbom_analysis", {}),
            "remediation_plan": remediation_output.results.get("remediation_plan", {}),
            "jira_enriched": jira_output.results.get("enriched", False) if jira_output else False
        }

        self.statistics["vulnerabilities_processed"] += 1

        return AgentOutput(
            agent_id=self.agent_id,
            agent_name=self.agent_name,
            status=AgentStatus.COMPLETED,
            results=comprehensive_results,
            confidence=0.85,
            reasoning=[
                "Completed comprehensive vulnerability management",
                "Enriched with business context",
                "Analyzed SBOM and dependency paths",
                "Generated remediation plan",
                "Enriched Jira ticket" if jira_output else "Jira enrichment skipped"
            ],
            data_sources_used=list(context.data_sources.keys()),
            recommendations=remediation_output.recommendations,
            next_actions=["Create MR/PR", "Monitor remediation progress"],
            audit_trail=[],
            execution_time=time.time() - start_time
        )

    # Helper methods

    def _parse_vulnerability_finding(self, vulnerability_data: Dict[str, Any]) -> VulnerabilityFinding:
        """Parse vulnerability data into VulnerabilityFinding object"""
        severity_map = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
            "informational": VulnerabilitySeverity.INFORMATIONAL
        }

        severity_str = vulnerability_data.get("severity", "medium").lower()
        severity = severity_map.get(severity_str, VulnerabilitySeverity.MEDIUM)

        return VulnerabilityFinding(
            vulnerability_id=vulnerability_data.get("vulnerability_id", "unknown"),
            cve_id=vulnerability_data.get("cve_id"),
            package_name=vulnerability_data.get("package_name", ""),
            package_version=vulnerability_data.get("package_version", ""),
            severity=severity,
            cvss_score=vulnerability_data.get("cvss_score", 0.0),
            description=vulnerability_data.get("description", ""),
            affected_asset_id=vulnerability_data.get("affected_asset_id"),
            affected_asset_name=vulnerability_data.get("affected_asset_name"),
            source=vulnerability_data.get("source", "unknown"),
            discovered_at=vulnerability_data.get("discovered_at"),
            metadata=vulnerability_data.get("metadata", {})
        )

    def _assess_business_context(
        self,
        finding: VulnerabilityFinding,
        context: AgentContext
    ) -> Dict[str, Any]:
        """Assess business context for vulnerability"""
        # In production, this would query asset databases, service catalogs, etc.
        return {
            "asset_criticality": "high",  # high, medium, low
            "customer_facing": True,
            "data_classification": "confidential",
            "deployment_frequency": "daily",
            "team_ownership": "platform-team",
            "business_impact": "Service disruption possible if exploited"
        }

    def _calculate_risk_score(
        self,
        finding: VulnerabilityFinding,
        context: AgentContext
    ) -> float:
        """Calculate risk score (0-10) based on multiple factors"""
        # Base score from CVSS
        base_score = finding.cvss_score

        # Adjust for business context
        business_context = self._assess_business_context(finding, context)

        # Criticality multiplier
        criticality_multiplier = {
            "high": 1.2,
            "medium": 1.0,
            "low": 0.8
        }.get(business_context.get("asset_criticality", "medium"), 1.0)

        # Customer-facing multiplier
        customer_facing_multiplier = 1.1 if business_context.get("customer_facing") else 1.0

        # Calculate final risk score
        risk_score = base_score * criticality_multiplier * customer_facing_multiplier

        # Cap at 10.0
        return min(risk_score, 10.0)

    def _determine_ownership(
        self,
        finding: VulnerabilityFinding,
        context: AgentContext
    ) -> Dict[str, Any]:
        """Determine team ownership for vulnerability"""
        # In production, this would analyze CODEOWNERS, git history, etc.
        return {
            "team": "platform-team",
            "primary_contact": "user@example.com",
            "secondary_contact": "user@example.com",
            "confidence": 0.85
        }

    def _determine_priority(
        self,
        finding: VulnerabilityFinding,
        context: AgentContext
    ) -> str:
        """Determine remediation priority"""
        risk_score = self._calculate_risk_score(finding, context)

        if risk_score >= 9.0:
            return "P0 - Critical"
        elif risk_score >= 7.0:
            return "P1 - High"
        elif risk_score >= 5.0:
            return "P2 - Medium"
        elif risk_score >= 3.0:
            return "P3 - Low"
        else:
            return "P4 - Informational"

    def _trace_dependency_path(
        self,
        sbom_data: Dict[str, Any],
        package_name: str,
        package_version: str
    ) -> Optional[DependencyPath]:
        """Trace dependency path to vulnerable package"""
        # Simplified implementation - in production, this would use proper SBOM parsing
        dependencies = sbom_data.get("dependencies", [])

        # Check if it's a direct dependency
        for dep in dependencies:
            if dep.get("name") == package_name and dep.get("version") == package_version:
                return DependencyPath(
                    root_package=sbom_data.get("name", "root"),
                    vulnerable_package=f"{package_name}@{package_version}",
                    path=[sbom_data.get("name", "root"), f"{package_name}@{package_version}"],
                    depth=1,
                    direct_dependency=package_name
                )

        # Check transitive dependencies (simplified)
        # In production, this would recursively traverse the dependency tree
        for dep in dependencies:
            transitive_deps = dep.get("dependencies", [])
            for trans_dep in transitive_deps:
                if trans_dep.get("name") == package_name:
                    return DependencyPath(
                        root_package=sbom_data.get("name", "root"),
                        vulnerable_package=f"{package_name}@{package_version}",
                        path=[
                            sbom_data.get("name", "root"),
                            f"{dep.get('name')}@{dep.get('version')}",
                            f"{package_name}@{package_version}"
                        ],
                        depth=2,
                        direct_dependency=dep.get("name")
                    )

        return None

    def _count_vulnerable_dependencies(self, sbom_data: Dict[str, Any]) -> int:
        """Count total vulnerable dependencies in SBOM"""
        # Simplified implementation
        return len(sbom_data.get("vulnerabilities", []))

    def _generate_remediation_plan(
        self,
        finding: VulnerabilityFinding,
        dependency_path: Optional[DependencyPath],
        context: AgentContext
    ) -> Dict[str, Any]:
        """Generate automated remediation plan"""
        if not dependency_path:
            return {
                "action": "manual_review",
                "description": "Unable to determine dependency path. Manual review required.",
                "automated": False,
                "estimated_effort_hours": 4.0,
                "risk_level": "medium"
            }

        # Determine fix action
        if dependency_path.depth == 1:
            # Direct dependency - can update directly
            action = "update_dependency"
            description = f"Update {dependency_path.direct_dependency} to a version that includes the fix for {finding.cve_id or finding.vulnerability_id}"
            automated = True
            estimated_effort = 1.0
        else:
            # Transitive dependency - need to update parent
            action = "update_parent_dependency"
            description = f"Update {dependency_path.direct_dependency} to a version that uses a patched version of {finding.package_name}"
            automated = True
            estimated_effort = 2.0

        return {
            "vulnerability_id": finding.vulnerability_id,
            "action": action,
            "description": description,
            "direct_dependency": dependency_path.direct_dependency,
            "current_version": finding.package_version,
            "fixed_version": "latest",  # In production, determine actual fixed version
            "breaking_changes": False,  # In production, analyze changelog
            "estimated_effort_hours": estimated_effort,
            "risk_level": "low",
            "automated": automated,
            "steps": [
                f"1. Update {dependency_path.direct_dependency} in package manifest",
                "2. Run dependency resolution (npm install, pip install, etc.)",
                "3. Run test suite",
                "4. Create MR/PR with changes",
                "5. Wait for CI/CD validation",
                "6. Merge and deploy"
            ]
        }

    def _build_jira_enrichment_comment(
        self,
        vulnerability_data: Dict[str, Any],
        enrichment: Dict[str, Any],
        remediation_plan: Dict[str, Any]
    ) -> str:
        """Build Jira comment with enrichment data"""
        lines = ["h2. ğŸ¤– AI-Powered Vulnerability Analysis", ""]

        # Business Context
        lines.append("h3. Business Context")
        business_context = enrichment.get("business_context", {})
        lines.append(f"* *Asset Criticality:* {business_context.get('asset_criticality', 'Unknown')}")
        lines.append(f"* *Customer Facing:* {'Yes' if business_context.get('customer_facing') else 'No'}")
        lines.append(f"* *Data Classification:* {business_context.get('data_classification', 'Unknown')}")
        lines.append(f"* *Team Ownership:* {enrichment.get('ownership', {}).get('team', 'Unknown')}")
        lines.append("")

        # Risk Assessment
        lines.append("h3. Risk Assessment")
        lines.append(f"* *Risk Score:* {enrichment.get('risk_score', 0.0):.1f}/10.0")
        lines.append(f"* *Priority:* {enrichment.get('priority', 'Unknown')}")
        lines.append(f"* *CVSS Score:* {vulnerability_data.get('cvss_score', 0.0)}")
        lines.append("")

        # Remediation Plan
        if remediation_plan:
            lines.append("h3. Automated Remediation Plan")
            lines.append(f"* *Action:* {remediation_plan.get('action', 'Unknown')}")
            lines.append(f"* *Description:* {remediation_plan.get('description', 'No description')}")
            lines.append(f"* *Estimated Effort:* {remediation_plan.get('estimated_effort_hours', 0)} hours")
            lines.append(f"* *Automated:* {'Yes' if remediation_plan.get('automated') else 'No'}")
            lines.append("")

            steps = remediation_plan.get("steps", [])
            if steps:
                lines.append("*Remediation Steps:*")
                for step in steps:
                    lines.append(step)
                lines.append("")

        # Next Actions
        lines.append("h3. Next Actions")
        lines.append("* Review remediation plan")
        lines.append("* Approve MR/PR creation")
        lines.append("* Monitor CI/CD pipeline")
        lines.append("* Validate fix deployment")
        lines.append("")

        lines.append("---")
        lines.append(f"_Generated by Vaulytica Vulnerability Management Agent v1.0.0 at {datetime.utcnow().isoformat()}_")

        return "\n".join(lines)

    def get_statistics(self) -> Dict[str, Any]:
        """Get agent statistics"""
        return self.statistics.copy()

