"""
Vulnerability Management for Vaulytica.

Provides comprehensive vulnerability assessment and management with:
- CVE database integration
- CVSS scoring and risk prioritization
- Vulnerability scanning for cloud resources
- Patch management tracking
- Exploit intelligence
- Remediation workflows

Author: Vaulytica Team
Version: 0.22.0
"""

import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass, field
from enum import Enum

from vaulytica.cspm import CloudResource, Severity, ResourceType
from vaulytica.logger import get_logger

logger = get_logger(__name__)


class VulnerabilitySource(str, Enum):
    """Vulnerability data sources."""
    NVD = "nvd"  # National Vulnerability Database
    MITRE = "mitre"
    EXPLOIT_DB = "exploit_db"
    GITHUB_ADVISORIES = "github_advisories"
    VENDOR_ADVISORIES = "vendor_advisories"


class ExploitMaturity(str, Enum):
    """Exploit maturity levels."""
    NOT_DEFINED = "not_defined"
    UNPROVEN = "unproven"
    PROOF_OF_CONCEPT = "proof_of_concept"
    FUNCTIONAL = "functional"
    HIGH = "high"


@dataclass
class CVEDetails:
    """CVE vulnerability details."""
    cve_id: str
    title: str
    description: str
    severity: Severity
    cvss_v3_score: float
    cvss_v3_vector: str
    cvss_v2_score: Optional[float] = None
    cvss_v2_vector: Optional[str] = None

    # Affected software
    affected_products: List[str] = field(default_factory=list)
    affected_versions: List[str] = field(default_factory=list)

    # Dates
    published_date: Optional[datetime] = None
    last_modified_date: Optional[datetime] = None

    # Exploit information
    exploit_available: bool = False
    exploit_maturity: ExploitMaturity = ExploitMaturity.NOT_DEFINED
    exploit_references: List[str] = field(default_factory=list)

    # Patch information
    patch_available: bool = False
    patch_references: List[str] = field(default_factory=list)

    # References
    references: List[str] = field(default_factory=list)
    cwe_ids: List[str] = field(default_factory=list)

    # Source
    source: VulnerabilitySource = VulnerabilitySource.NVD


@dataclass
class VulnerabilityAssessment:
    """Vulnerability assessment for a resource."""
    assessment_id: str
    resource: CloudResource
    vulnerabilities: List[CVEDetails] = field(default_factory=list)
    risk_score: float = 0.0
    priority: Severity = Severity.INFO
    assessed_at: datetime = field(default_factory=datetime.utcnow)
    next_assessment: Optional[datetime] = None


@dataclass
class RemediationAction:
    """Remediation action for a vulnerability."""
    action_id: str
    vulnerability: CVEDetails
    action_type: str  # patch, upgrade, configuration_change, workaround
    description: str
    steps: List[str] = field(default_factory=list)
    estimated_effort: str = "medium"  # low, medium, high
    risk_of_change: str = "medium"  # low, medium, high
    requires_downtime: bool = False
    automated: bool = False
    iac_template: Optional[str] = None  # Terraform/CloudFormation template


class VulnerabilityScanner:
    """
    Vulnerability scanner for cloud resources.

    Scans resources for known vulnerabilities using CVE database.
    """

    def __init__(self):
        """Initialize vulnerability scanner."""
        self.cve_database: Dict[str, CVEDetails] = {}
        self.assessments: Dict[str, VulnerabilityAssessment] = {}

        self.statistics = {
            "total_scans": 0,
            "vulnerabilities_found": 0,
            "vulnerabilities_by_severity": {s.value: 0 for s in Severity},
            "resources_scanned": 0,
            "last_scan": None
        }

        # Initialize CVE database
        self._initialize_cve_database()

        logger.info(f"Vulnerability Scanner initialized with {len(self.cve_database)} CVEs")

    def _initialize_cve_database(self):
        """Initialize CVE database with sample data."""
        # Sample CVEs - in production, integrate with NVD API
        self.cve_database["CVE-2023-12345"] = CVEDetails(
            cve_id="CVE-2023-12345",
            title="Remote Code Execution in Cloud Service",
            description="A critical vulnerability allows remote code execution through unauthenticated API endpoints.",
            severity=Severity.CRITICAL,
            cvss_v3_score=9.8,
            cvss_v3_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            affected_products=["cloud-service"],
            affected_versions=["< 2.5.0"],
            published_date=datetime(2023, 6, 1),
            exploit_available=True,
            exploit_maturity=ExploitMaturity.FUNCTIONAL,
            patch_available=True,
            patch_references=["https://example.com"],
            cwe_ids=["CWE-78"]
        )

        self.cve_database["CVE-2023-23456"] = CVEDetails(
            cve_id="CVE-2023-23456",
            title="SQL Injection in Database Service",
            description="SQL injection vulnerability in database query interface.",
            severity=Severity.HIGH,
            cvss_v3_score=8.1,
            cvss_v3_vector="CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N",
            affected_products=["database-service"],
            affected_versions=["< 3.2.1"],
            published_date=datetime(2023, 7, 15),
            exploit_available=False,
            patch_available=True,
            cwe_ids=["CWE-89"]
        )

        self.cve_database["CVE-2023-34567"] = CVEDetails(
            cve_id="CVE-2023-34567",
            title="Information Disclosure in Storage Service",
            description="Sensitive information disclosure through misconfigured access controls.",
            severity=Severity.MEDIUM,
            cvss_v3_score=5.3,
            cvss_v3_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
            affected_products=["storage-service"],
            affected_versions=["< 1.8.0"],
            published_date=datetime(2023, 8, 20),
            exploit_available=False,
            patch_available=True,
            cwe_ids=["CWE-200"]
        )

    async def scan_resource(self, resource: CloudResource) -> VulnerabilityAssessment:
        """
        Scan a resource for vulnerabilities.

        Args:
            resource: Resource to scan

        Returns:
            Vulnerability assessment
        """
        logger.info(f"Scanning resource {resource.resource_id} for vulnerabilities")

        vulnerabilities = []

        # Check for vulnerabilities based on resource type and configuration
        if resource.resource_type == ResourceType.VM_INSTANCE:
            # Check for OS vulnerabilities
            vulnerabilities.extend(await self._scan_vm_vulnerabilities(resource))

        elif resource.resource_type == ResourceType.DATABASE:
            # Check for database vulnerabilities
            vulnerabilities.extend(await self._scan_database_vulnerabilities(resource))

        elif resource.resource_type == ResourceType.STORAGE_BUCKET:
            # Check for storage vulnerabilities
            vulnerabilities.extend(await self._scan_storage_vulnerabilities(resource))

        # Calculate risk score
        risk_score = self._calculate_risk_score(vulnerabilities, resource)
        priority = self._determine_priority(risk_score, vulnerabilities)

        # Create assessment
        assessment = VulnerabilityAssessment(
            assessment_id=f"vuln-{resource.resource_id}-{datetime.utcnow().timestamp()}",
            resource=resource,
            vulnerabilities=vulnerabilities,
            risk_score=risk_score,
            priority=priority,
            next_assessment=datetime.utcnow() + timedelta(days=7)
        )

        self.assessments[assessment.assessment_id] = assessment

        # Update statistics
        self.statistics["total_scans"] += 1
        self.statistics["resources_scanned"] += 1
        self.statistics["vulnerabilities_found"] += len(vulnerabilities)
        for vuln in vulnerabilities:
            self.statistics["vulnerabilities_by_severity"][vuln.severity.value] += 1
        self.statistics["last_scan"] = datetime.utcnow().isoformat()

        logger.info(f"Found {len(vulnerabilities)} vulnerabilities for {resource.resource_id}")

        return assessment

    async def _scan_vm_vulnerabilities(self, resource: CloudResource) -> List[CVEDetails]:
        """Scan VM instance for vulnerabilities."""
        vulnerabilities = []

        # Mock vulnerability detection
        # In production, integrate with vulnerability scanners
        if not resource.configuration.get("monitoring_enabled"):
            # Add mock vulnerability
            vulnerabilities.append(self.cve_database.get("CVE-2023-12345"))

        return [v for v in vulnerabilities if v is not None]

    async def _scan_database_vulnerabilities(self, resource: CloudResource) -> List[CVEDetails]:
        """Scan database for vulnerabilities."""
        vulnerabilities = []

        # Check for SQL injection vulnerabilities
        if not resource.configuration.get("encrypted"):
            vulnerabilities.append(self.cve_database.get("CVE-2023-23456"))

        return [v for v in vulnerabilities if v is not None]

    async def _scan_storage_vulnerabilities(self, resource: CloudResource) -> List[CVEDetails]:
        """Scan storage for vulnerabilities."""
        vulnerabilities = []

        # Check for information disclosure
        if resource.configuration.get("public_access_block") == False:
            vulnerabilities.append(self.cve_database.get("CVE-2023-34567"))

        return [v for v in vulnerabilities if v is not None]

    def _calculate_risk_score(self, vulnerabilities: List[CVEDetails], resource: CloudResource) -> float:
        """Calculate overall risk score."""
        if not vulnerabilities:
            return 0.0

        # Base score from CVSS
        base_score = sum(v.cvss_v3_score for v in vulnerabilities) / len(vulnerabilities)

        # Adjust for exploit availability
        exploit_multiplier = 1.0
        if any(v.exploit_available for v in vulnerabilities):
            exploit_multiplier = 1.5

        # Adjust for environment
        env_multiplier = 1.0
        if resource.tags.get("Environment") == "production":
            env_multiplier = 1.3

        # Adjust for public exposure
        exposure_multiplier = 1.0
        if resource.configuration.get("public_ip") or resource.configuration.get("public_access_block") == False:
            exposure_multiplier = 1.4

        risk_score = base_score * exploit_multiplier * env_multiplier * exposure_multiplier

        return min(risk_score, 10.0)

    def _determine_priority(self, risk_score: float, vulnerabilities: List[CVEDetails]) -> Severity:
        """Determine priority based on risk score."""
        if risk_score >= 9.0:
            return Severity.CRITICAL
        elif risk_score >= 7.0:
            return Severity.HIGH
        elif risk_score >= 4.0:
            return Severity.MEDIUM
        elif risk_score >= 1.0:
            return Severity.LOW
        else:
            return Severity.INFO

    async def scan_all_resources(self, resources: List[CloudResource]) -> List[VulnerabilityAssessment]:
        """Scan all resources for vulnerabilities."""
        logger.info(f"Scanning {len(resources)} resources for vulnerabilities")

        assessments = []
        for resource in resources:
            assessment = await self.scan_resource(resource)
            assessments.append(assessment)

        return assessments

    def get_assessment(self, assessment_id: str) -> Optional[VulnerabilityAssessment]:
        """Get assessment by ID."""
        return self.assessments.get(assessment_id)

    def get_assessments_by_severity(self, severity: Severity) -> List[VulnerabilityAssessment]:
        """Get assessments by priority severity."""
        return [a for a in self.assessments.values() if a.priority == severity]

    def get_statistics(self) -> Dict[str, Any]:
        """Get scanner statistics."""
        return self.statistics


# Global instance
_vulnerability_scanner: Optional[VulnerabilityScanner] = None


def get_vulnerability_scanner() -> VulnerabilityScanner:
    """Get or create global vulnerability scanner instance."""
    global _vulnerability_scanner

    if _vulnerability_scanner is None:
        _vulnerability_scanner = VulnerabilityScanner()

    return _vulnerability_scanner
